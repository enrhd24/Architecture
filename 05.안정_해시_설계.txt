안정 해시(Consistent Hashing)
: 수평적 규모 확장성을 달성하기 위해 보편적으로 사용하는 기술
: 일반적으로 요청 또는 데이터를 서버에 균등하게 나누기

안정해시의 탄생 배경
: 해시 키 재배치 문제
: 해시함수를 사용하여 요청 또는 데이터를 서버에 균등하게 나눈다.
: serverIndex = hash(key)%N(N은 서버의 개수)

예제> (총 4대의 서버를 사용)
: hash(keyN)%4=? 
-> 클라이언트는 캐시에 보관된 데이터를 가져오기 위해 서버?애 접속한다.
-> 서버인덱스 - ? , 서버N개 , 해당 해시키 나열
위에 예제로 부터 잘동작하는 때
1. 서버풀(server pool)의 크기가 고정
2. 데이터 분포 균등

해당티의 장애로 동작이 중단된 경우
: 서버 풀의 크기가 변화되어 서버의 수가 1만큼 줄어든다.
: 해당 서버의 보관되어있는 키는 재분배된다.

정리 
: 서버가 죽으면 캐시 클라이언트가 데이터가 없는 엉뚱한 서버에 접속하게 된다.
: 대규모 캐시미스(cache miss)가 발생하게 될 것이다.
// 안정해시는 이 문제를 효과적으로 해결하는 기술이다.

---

안정해시( k:키의 개수, n:슬롯(slot)의 개수 )
: 해시 테이블 크기가 조정될 때 k/n개의 키만 재배치하는 해시 기술

전통적인 해시 테이블 : 슬롯의 수가 바귀면 거의 대부분 키를 재배치한다.

안정 해시의 동작원리

- 해시공간
: 함수의 출력 값 범위 x0,x1,x2,...,xn
: x0dms 0, xn은 2^160-1, SHA-1의 해시 공안(hash space)범위

- 해시 링   : 해시 공간의 양쪽을 구부려 접으면 hash ring이 만들어 진다.
- 해시 서버 : 해시 함수f 사용시 서버IP를 링위에 어떤 위치에 대응할 수 있음.
- 해시 키   : 나머지 연산없이 캐시할 키 또한 링 위의 어느 지점에 배치가능.

- 서버 조회 : 해당 키의 위치로부터 시계방향으로 링을 탐색하는 첫번째 서버
- 서버 추가 : 새로운 서버가 추가될 시 시계방향으로 처음만나는 서버4이기 때문
- 서버 제거 : 하나의 서버가 제거되면 키 가운데 일부만 재배치된다. 


기본구현법의 2가지 문제
1. 파티션의 크기를 균등하게 유지하는 게 불가능
2. 키의 균등 분포를 달성하기 어렵다

---

가상노드(virual node)-복제(replica) : 기본구현법의 문제를 해결하기 위한 제안된 기법
- 실제 노드 or 서버를 가리키는 노드
- 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있음
  각 서버는 하나가 아닌 여러 개 파티션을 관리해야 한다.

1. 최초의 기상 노드가 해당 키가 저장될 서버 
: 가상 노드의 개수를 늘리면 키의 분포는 점점 더 균등해진다.
: 표쥰 편차가 작아져서 데이터가 고르게 분포되기 때문이다.
// 가상 노드 데이터를 저장할 공간으로 타협적 결정(tradeoff)가 필요하다.

2. 재배치할 키 결정
: 반시계 방향에 잇는 첫번째 서버가 저장될 서버가 된다.
: 첫번째 서버부터 두번째 서버가지 첫 서버로 재배치 하여야 한다.
// 서버 삭제시 반시계방향에 잇는 최초 서버 사이에 있는 키들이 재배치되어야 함.

---

정리의 시간
1. 안정해시가 왜 필요하나요?
2. 안정해시는 어떻게 동작하나요?
3. 데이터가 균등하게 분포하게 되면 수평적 규모 확장성을 달성하기 쉽다.
4. 서버가 추가되고 삭제될대 재배치되는 키의 수가 최소화된다.
5. 핫스팟 키 문제를 줄인다, 
   특정한 샤드(shard)에 대한 접근이 빈번하면 서버 과부하가 일어난다.

--- 
질문
1. 서버풀(server pool)
2. 샤드(shard)

